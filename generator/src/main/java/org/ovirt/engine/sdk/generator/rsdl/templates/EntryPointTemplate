class API(object):
    def __init__(self, url, username=None, password=None, key_file=None,
                 cert_file=None, ca_file=None, port=None, timeout=None,
                 session_timeout=None, persistent_auth=True,
                 renew_session=False, insecure=False,
                 validate_cert_chain=True, filter=False, debug=False,
                 kerberos=False): # @ReservedAssignment

        '''
        @param url: server url (format "http/s://server[:port]/ovirt-engine/api")
        [@param username: user (format user@domain)]
        [@param password: password]
        [@param key_file: client PEM key_file for ssl enabled connection]
        [@param cert_file: client PEM cert_file for ssl enabled connection]
        [@param ca_file: server ca_file for ssl enabled connection]
        [@param port: port to use (if not specified in url)]
        [@param timeout: request timeout]
        [@param session_timeout: authentication session timeout in minutes (if persistent_auth is enabled)]
        [@param persistent_auth: use persistent authentication (default is True)]
        [@param renew_session: automatically renew expired authentication session (default is False)]
        [@param insecure: signals to not demand site trustworthiness for ssl enabled connection (default is False)]
        [@param validate_cert_chain: validate the server's CA certificate (default is True)]
        [@param filter: enables user-api filtering (default is False)]
        [@param debug: debug (format True|False)]
        [@param kerberos: use Kerberos authentication (default is False)]

        @raise NoCertificatesError: raised when CA certificate is not provided for SSL site (can be disabled using 'insecure=True' argument).
        @raise UnsecuredConnectionAttemptError: raised when HTTP protocol is used in url against server running HTTPS.
        @raise ImmutableError: raised on sdk < 3.2 when sdk initiation attempt occurred while sdk instance already exist under the same domain.
        @raise DisconnectedError: raised when sdk usage attempt occurred after it was explicitly disconnected.
        @raise MissingParametersError: raised when get() method invoked without id or name been specified.
        @raise ConnectionError: raised when any kind of communication error occurred.
        @raise RequestError: raised when any kind of oVirt server error occurred.
        @raise FormatError: raised when server replies in non-XML format.
        '''

        # The instance id
        self.__id = id(self)

        # Implicitly disconnect and perform cleanup
        # when detected instance of the SDK proxy with
        # ref-count == 0
        if context.manager.has_key(self.__id) and context.manager[self.__id].get('proxy') is not None:
            try:
                self.disconnect()
            except DisconnectedError:
                pass

        # Parse the URL in order to simplify the manipluations that we are
        # going to perform:
        parsed_url = urlparse.urlparse(url)

        # Remove trailing slashes from the path:
        path = parsed_url.path
        path = re.sub(r"/+$", "", path)

        # For backwards compatibility we need to support URLs that don't
        # contain a path, and in that case the path should be the old /api:
        if path == '':
            path = '/api'

        # If the URL doesn't explicitly specify the port but it is explicitly
        # given as a parameter then we need to modify the URL so that it
        # contains that port:
        netloc = parsed_url.netloc
        if parsed_url.port is None and port is not None:
            netloc += ":%s" % port

        # Rebuild the URL, ignoring everything but the scheme, network
        # location and path (these aren't supported by the SDK):
        parsed_url = urlparse.ParseResult(
            scheme=parsed_url.scheme,
            netloc=netloc,
            path=path,
            params="",
            query="",
            fragment=""
        )
        url = parsed_url.geturl()

        # Create the connection pool:
        pool = ConnectionsPool(
            url=url,
            username=username,
            password=password,
            context_key=self.id,
            key_file=key_file,
            cert_file=cert_file,
            ca_file=ca_file,
            timeout=timeout,
            insecure=insecure,
            validate_cert_chain=validate_cert_chain,
            debug=debug,
            kerberos=kerberos
        )

        # Create the proxy:
        proxy = Proxy(
            pool,
            persistent_auth,
            path
        )

        # Store filter to the context:
        self.set_filter(filter)

        # We need to remember if renew_session is enabled:
        self.set_renew_session(renew_session)

        # Store session_timeout to the context:
        self.__set_session_timeout(session_timeout)

        # Get entry point
        entry_point = proxy.request(
            method='GET',
            url=''
        )

        # If server returns no response for the root resource, this is sign
        # that used http protocol against SSL secured site
        if type(entry_point) == types.StringType and entry_point == '':
            raise UnsecuredConnectionAttemptError

        # Store entry point to the context
        context.manager[self.id].add(
            'entry_point',
            entry_point,
            Mode.R
        )

        # Store proxy to the context:
        context.manager[self.id].add(
            'proxy',
            proxy,
            Mode.R
        )

        # We need to remember if persistent auth is enabled:
        context.manager[self.id].add(
            'persistent_auth',
             persistent_auth,
             Mode.R,
             typ=types.BooleanType
        )
